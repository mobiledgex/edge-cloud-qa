All Files and Testcase names:
getAppInstList_1app_carrierMismatch.robot
['GetAppInstList - request shall return only app that matches carrier']
getAppInstList_1app.robot
['GetAppInstList - request shall return 1 app']
getAppInstList_0app.robot
['GetAppInstList - request with no app instance shall return 0 app']
getAppInstList_azure.robot
['GetAppInstList - request shall return azure app']
getAppInstList_10cloudlet.robot
['GetAppInstList - request shall return 10 cloudlets']
getAppInstList_defaultCloudlet.robot
['GetAppInstList - request shall not return default cloudlet apps']
getAppInstList_appMultiplePorts.robot
['GetAppInstList - request shall return app with mulitple ports']
getAppInstList_gcp.robot
['GetAppInstList - request shall return GCP app']
getAppInstList_noGps.robot
['GetAppInstList - request shall fail with no GPS coords']
getAppInstList_noPorts.robot
['GetAppInstList - request shall return app with no ports']
getAppInstList_cookieError.robot
["GetAppInstList - request without cookie should return 'missing cookie'", "GetAppInstList - request with invalid cookie of x should return 'token contains an invalid number of segments'", "GetAppInstList - request with invalid cookie of x.x.x should return 'illegal base64 data at input byte 1' with invalid cookie", "GetAppInstList - request with truncated cookie should return 'VerifyCookie failed: Invalid cookie, no key'", "GetAppInstList - request with expired cookie should return 'token is expired by'"]
getLocation_cookieError.robot
['#VerifyLocation - request with bad session cookie shall return app not found', "GetLocation - request without cookie should return 'missing cookie'", "GetLocation - request with invalid cookie of x should return 'token contains an invalid number of segments'", "GetLocation - request with invalid cookie of x.x.x should return 'illegal base64 data at input byte 1' with invalid cookie", "GetLocation - request with truncated cookie should return 'VerifyCookie failed: Invalid cookie, no key'", "GetLocation - request with expired cookie should return 'token is expired by'"]
getLocation.robot
['GetLocation - request should return LOC_FOUND']
verifyLocation_carrierNotFound.robot
['VerifyLocation - request with carrier not found should pass']
verifyLocation_2km.robot
['VerifyLocation - request with same coord shall return LOC_VERIFIED of 2KM ', 'VerifyLocation - request within < 2KM shall return LOC_VERIFIED of 2KM']
verifyLocation_cookieError.robot
['VerifyLocation - request with bad session cookie shall return app not found', "VerifyLocation - request without cookie should return 'missing cookie'", "VerifyLocation - request with invalid cookie of x should return 'token contains an invalid number of segments'", "VerifyLocation - request with invalid cookie of x.x.x should return 'illegal base64 data at input byte 1' with invalid cookie", "VerifyLocation - request with truncated cookie should return 'VerifyCookie failed: Invalid cookie, no key'", "VerifyLocation - request with expired cookie should return 'token is expired by'"]
verifyLocation_missingParms.robot
["VerifyLocation - request without lat/long should return 'Missing GpsLocation'", 'VerifyLocation - request without carrier should succeed', "VerifyLocation - request without token should return 'verifyloc token required'", 'VerifyLocation - request with latitude only should succeed', 'VerifyLocation - request with longitude only should succeed']
verifyLocation_10km.robot
['VerifyLocation - request with coord barely > 2km and < 10km shall return LOC_VERIFIED of 10km', 'VerifyLocation - request with coord > 2km and < 10km shall return LOC_VERIFIED of 10km']
verifyLocation_greater100km_roaming_other_country.robot
['VerifyLocation - request claiming to be in neighboring country but actually home shall return LOC_ROAMING_COUNTRY_MISMATCH', 'VerifyLocation - request claiming to be overseas but actually home shall return LOC_ROAMING_COUNTRY_MISMATCH']
verifyLocation_badToken_rest.robot
['#EDGECLOUD-369 - VerifyToken with token=xx does not return LOC_ERROR_UNAUTHORIZED', "VerifyLocation REST - request with empty token shall return 'verifyloc token required'"]
verifyLocation_badToken.robot
['#EDGECLOUD-369 - VerifyToken with token=xx does not return LOC_ERROR_UNAUTHORIZED', "VerifyLocation - request with empty token shall return 'verifyloc token required'"]
verifyLocation_100km.robot
['VerifyLocation - request with coord barely > 10km and < 100km shall return LOC_VERIFIED of 100km', 'VerifyLocation - request with coord > 10km and < 100km shall return LOC_VERIFIED of 100km']
verifyLocation_greater100km_other_country.robot
['VerifyLocation - request claiming to be home but actually in neighboring country shall return LOC_MISMATCH_OTHER_COUNTRY', 'VerifyLocation - request claiming to be home but actually overseas shall return LOC_MISMATCH_OTHER_COUNTRY']
verifyLocation_invalidParms.robot
["VerifyLocation - request with invalid low lat should return 'Invalid GpsLocation'", "VerifyLocation - request with invalid high lat should return 'Invalid GpsLocation'", "VerifyLocation - request with invalid low long should return 'Invalid GpsLocation'", "VerifyLocation - request with invalid high long should return 'Invalid GpsLocation'"]
verifyLocation_greater100km_roaming_same_country.robot
['VerifyLocation - request claiming to be in neighboring country and actually there shall return LOC_ROAMING_COUNTRY_MATCH', 'VerifyLocation - request claiming to be overseas and actually there shall return LOC_ROAMING_COUNTRY_MATCH']
verifyLocation_greater100km_same_country.robot
['VerifyLocation - request with coord barely > 100km and still within country shall return LOC_MISMATCH_SAME_COUNTRY', 'VerifyLocation - request with coord > 100km and within same country shall return LOC_MISMATCH_SAME_COUNTRY']
registerClient_missingParms.robot
["RegisterClient - request with app_name only shall return 'DevName cannot be empty'", "RegisterClient - request with app_version only shall return 'DevName cannot be empty'", "RegisterClient - request with developer name only shall return 'AppName cannot be empty'", "RegisterClient - request without developer name shall return 'DevName cannot be empty'", "RegisterClient - request without app version shall return 'AppVers cannot be empty'", "RegisterClient - request without app name shall return 'AppName cannot be empty'", "RegisterClient - request without authtoken for app with token shall return 'No authtoken received'"]
registerClient_appNotFound.robot
["RegisterClient - request with wrong app_name shall return 'app not found'", "RegisterClient - request with wrong app_version shall return 'app not found'", "RegisterClient - request with wrong developer_name shall return 'app not found'", "RegisterClient - request with wrong app_name,app_version, and developer_name shall return 'app not found'", 'RegisterClient - request shall succeed after adding app']
registerClient_auth.robot
['RegisterClient - request with auth shall return proper JWT']
registerClient_multiple.robot
['RegisterClient - register shall work when keep creating/deleting same app instance ']
registerClient_traffic_rest.robot
['RegisterClient - DME should handle simultaneous register requests ', 'FindCloudlet - DME should handle simultaneous FindCloudlet requests ', 'VerifyLocation - DME should handle simultaneous VerifyLocation requests ']
registerClient_authFail.robot
["RegisterClient - request for app without authpublickey shall return 'No authkey found to validate token'", "RegisterClient - request with invalid version in token shall return 'failed to verify token - token appvers mismatch'", "RegisterClient - request with invalid appname in token shall return 'failed to verify token - token appname mismatch'", "RegisterClient - request with invalid devname in token shall return 'failed to verify token - token developer mismatch'", "RegisterClient - request with invalid token shall return 'failed to verify token - token contains an invalid number of segments'", "RegisterClient - request with expired token shall return 'failed to verify token - token is expired'"]
registerClient.robot
['RegisterClient - request without auth shall return proper JWT']
getFqdnList_nonSamsung.robot
['GetFqdnList - request fqdnlist for non-samsung app should fail']
getFqdnList_cookieError.robot
["GetFqdnList - request without cookie should return 'missing cookie'", "GetFqdnList - request with invalid cookie of x should return 'token contains an invalid number of segments'", "GetFqdnList - request with invalid cookie of x.x.x should return 'illegal base64 data at input byte 1' with invalid cookie", "GetFqdnList - request with truncated cookie should return 'VerifyCookie failed: Invalid cookie, no key'", "GetFqdnList - request with expired cookie should return 'token is expired by'"]
getFqdnList_permitMixture.robot
['GetFqdnList - request shall only return apps with permits_platform_apps=True']
getFqdnList_1app.robot
['GetFqdnList - request shall return 1 app']
getFqdnList_0app.robot
['GetFqdnList - request shall return 0 apps']
getFqdnList_10app.robot
['GetFqdnList - request shall return 10 apps']
getFqdnList_0appPermitNone.robot
['GetFqdnList - request for apps with no permits_platform_apps shall return 0 apps']
getFqdnList_0appPermitFalse.robot
['GetFqdnList - request for apps with permits_platform_apps=False shall return 0 apps']
start_dme_fail.robot
['DME shall fail to start when cert is not found ', 'DME shall fail to start without cloudlet name', 'DME shall fail to start without cloudlet operator name', 'DME shall fail to start without cloudletKey parm', 'DME shall fail to start with invalid cloudletKey', 'DME shall fail to start without carrier parm', 'DME shall fail to start if port is in use']
findCloudlet_invalidParms.robot
["FindCloudlet - request with too small latitude should return 'Invalid GpsLocation'", "FindCloudlet - request with too large latitude should return 'Invalid GpsLocation'", "FindCloudlet - request with too small longitude should return 'Invalid GpsLocation'", "FindCloudlet - request with too large longitude should return 'Invalid GpsLocation'", "FindCloudlet - request with out-of-range latitude/longitude should return 'Invalid GpsLocation'"]
findCloudlet_tmus_azureCloser_noAppinst.robot
['FindCloudlet - request shall return tmus with azure cloudlet closer but no appinst provisioned']
findCloudlet_tmus_noGcpNoAzure.robot
['FindCloudlet - request shall return tmus with no gcp/azure provisioned ond same coord as tmocloud-1', 'FindCloudlet - request shall return tmus with no gcp/azure provisioned ond same coord as tmocloud-2', 'FindCloudlet - request shall return tmus with no gcp/azure provisioned ond coord closer to tmocloud-1', 'FindCloudlet - request shall return tmus with no gcp/azure provisioned ond coord closer to tmocloud-2', 'FindCloudlet - request shall return tmus with no gcp/azure provisioned ond coord of max distance ', 'FindCloudlet - request shall return tmus with no gcp/azure provisioned ond coord of min distance']
findCloudlet_samsung_permitsPlatformAppsFalse.robot
['FindCloudlet Samsung - request shall return error when sending FindCloudlet for app with permits_platform_apps=False']
findCloudlet_timestamp_rest.robot
['FindCloudlet REST - request with timestamp shall return tmus']
findCloudlet_tmus_tmusCloserThanGcpAzureGreaterThan100km.robot
['FindCloudlet - request shall return tmus with gcp/azure cloudlet provisioned and tmus closer and > 100km from request']
findCloudlet_tmus_tmusGcpSameCoord.robot
['FindCloudlet - request shall return tmus with gcp cloudlet provisioned and tmus and gcp same coord']
findCloudlet_samsung_missingParms.robot
['FindCloudlet Samsung - request shall return error when registering samsung app and sending findCloudlet overriding appname only', 'FindCloudlet Samsung - request shall return error when registering samsung app and sending findCloudlet overriding appvers only', 'FindCloudlet Samsung - request shall return error when registering samsung app and sending findCloudlet overriding developername only']
findCloudlet_cookieError_rest.robot
["FindCloudlet - request without cookie should return 'missing cookie'", "FindCloudlet - request with invalid cookie of x should return 'token contains an invalid number of segments'", "FindCloudlet - request with invalid cookie of x.x.x should return 'illegal base64 data at input byte 1' with invalid cookie", "FindCloudlet - request with truncated cookie should return 'VerifyCookie failed: Invalid cookie, no key'", "FindCloudlet - request with expired cookie should return 'token is expired by'"]
findCloudlet_tmus_tmusFartherThanGcpLessThan100km.robot
['FindCloudlet - request shall return tmus with gcp cloudlet provisioned and tmus farther but < 100km than gcp']
findCloudlet_tmus_tmusCloserThanGcpAzure_largeDistance.robot
['FindCloudlet - request shall return tmus with gcp/azure cloudlet provisioned and tmus closer and with large distances']
findCloudlet_samsung_azure_azureCloser.robot
['FindCloudlet Samsung - findCloudlet shall return azure with with azure cloudlet provisioned and closer by more than 100km']
findCloudlet_tmus_tmusGcpSameDistance.robot
['FindCloudlet - request shall return tmus with gcp cloudlet provisioned and tmus and gcp same distance away']
findCloudlet_cookieError.robot
["FindCloudlet - request without cookie should return 'missing cookie'", "FindCloudlet - request with invalid cookie of x should return 'token contains an invalid number of segments'", "FindCloudlet - request with invalid cookie of x.x.x should return 'illegal base64 data at input byte 1' with invalid cookie", "FindCloudlet - request with truncated cookie should return 'VerifyCookie failed: Invalid cookie, no key'", "FindCloudlet - request with expired cookie should return 'token is expired by'"]
findCloudlet_tmus_tmusAzureSameCoord.robot
['FindCloudlet - request shall return tmus with azure cloudlet provisioned and tmus and azure same coord']
findCloudlet_gcp_requestGcp.robot
['FindCloudlet - request shall return gcp with tmus and gcp/azure cloudlet provisioned and requesting gcp']
findCloudlet_tmus_tmusAzureSameDistance.robot
['FindCloudlet shall return tmus with azure cloudlet provisioned and tmus and azure same distance']
findCloudlet_tmus_tmusGcpAzureSameCoord.robot
['FindCloudlet - request shall return tmus with azure/gcp cloudlet provisioned and tmus/azure/gcp same coord']
findCloudlet_tmus_tmusCloserThanGcpLessThan100km.robot
['FindCloudlet - request shall return tmus with gcp cloudlet provisioned and tmus closer and < 100km from request']
findCloudlet_samsung_tmus_tmusCloserThanAzureGreaterThan100km.robot
['FindCloudlet Samsung - request shall return tmus with azure cloudlet provisioned and tmus closer and > 100km from request']
findCloudlet_tmus_tmusCloserThanAzureLessThan100km.robot
['FindCloudlet - request shall return tmus with azure cloudlet provisioned and tmus closer and < 100km from request']
findCloudlet_tmus_gcpCloser_noAppinst.robot
['FindCloudlet - request shall return tmus with gcp cloudlet closer but no appinst provisioned']
findCloudlet_samsung_gcp_gcpCloser.robot
['FindCloudlet Samsung - request shall return gcp with tmus farther and > 100km farther than gcp']
findCloudlet_tmus_tmusFartherThanGcpAzureLessThan100km.robot
['FindCloudlet - request shall return tmus with gcp/azure cloudlet provisioned and tmus farther but < 100km from gcp/azure']
findCloudlet_tmus_multiple.robot
['FindCloudlet - request shall return proper cloudlet when multiple cloudlets exist']
findCloudlet_samsung_tmus_tmusCloserThanGcpAzureLessThan100km.robot
['FindCloudlet Samsung - request shall return tmus with gcp/azure cloudlet provisioned and tmus closer and < 100km from request']
findCloudlet_gcp_gcpCloser.robot
['FindCloudlet - request shall return gcp with tmus farther and > 100km farther than gcp']
findCloudlet_azure_requestAzure.robot
['FindCloudlet - request shall return azure with tmus and gcp/azure cloudlet provisioned and requesting azure']
findCloudlet_missingParms.robot
["FindCloudlet - request without lat/long should return 'Missing GpsLocation'", "FindCloudlet - request without carrier name should return 'missing carrierName'", "FindCloudlet - request with latitude only should return 'missing carrierName'", "FindCloudlet - request with longitude only should return 'missing carrierName'", 'FindCloudlet - request with carrier_name and latitude only should succeed', 'FindCloudlet - request with carrier_name and longitude only should succeed']
findCloudlet_gcp_GcpCloserThanTmusAzure_gcpGreaterThan100km_azureGreaterThan100km.robot
['FindCloudlet - request shall return gcp with tmus and gcp/azure cloudlet provisioned and tmus farther and > 100km from gcp and azure and gcp closer than azure']
findCloudlet_tmus_registerFindMismatch.robot
['FindCloudlet - request shall return error when FindCloudlet app does not match Registered App']
findCloudlet_azure_azureCloser.robot
['FindCloudlet - findCloudlet shall return azure with with azure cloudlet provisioned and closer by more than 100km']
findCloudlet_tmus_tmusFartherThanAzureLessThan100km.robot
['FindCloudlet - request shall return tmus with azure cloudlet provisioned and tmus farther but < 100km than azure']
findCloudlet_samsung_findSamsungApp.robot
['FindCloudlet Samsung - request shall return FIND_NOTFOUND when registering samsung app and sending findCloudlet without overriding the appname', 'FindCloudlet Samsung - request shall return FIND_NOTFOUND when registering samsung app and sending findCloudlet overriding the appname with samsung app']
findCloudlet_tmus_tmusCloserThanGcpAzureLessThan100km.robot
['FindCloudlet - request shall return tmus with gcp/azure cloudlet provisioned and tmus closer and < 100km from request']
findCloudlet_gcp_gcpCloserThanTmusAzure_gcpGreaterThan100km_azureLessThan100km.robot
['FindCloudlet - request shall return gcp with tmus and gcp/azure cloudlet provisioned and tmus farther and > 100km than gcp and < 100km than azure and gcp closer than azure']
findCloudlet_samsung_permitsPlatformAppsMissing.robot
['FindCloudlet Samsung - request shall return error when sending FindCloudlet for app without permits_platform_apps']
findCloudlet_tmus_tmusCloserThanAzureGreaterThan100km.robot
['FindCloudlet - request shall return tmus with azure cloudlet provisioned and tmus closer and > 100km from request']
findCloudlet_tmus_tmusCloserThanGcpGreaterThan100km.robot
['FindCloudlet - request shall return tmus with gcp cloudlet provisioned and tmus closer and > 100km from request']
findCloudlet_tmus_cloudletNotFound.robot
['FindCloudlet - request shall return FIND_NOT_FOUND when requesting an operator that doesnt exist']
findCloudlet_azure_azureCloserThanTmusGcp_azureGreaterThan100km_gcpLessThan100km.robot
['FindCloudlet - request shall return azure with tmus and gcp/azure cloudlet provisioned and tmus farther but > 100km than azure and < 100km than gcp and azure closer than gcp']
findCloudlet_azure_azureCloserThanTmusGcp_azureGreaterThan100km_gcpGreaterThan100km.robot
['FindCloudlet - request shall return azure with tmus and gcp/azure cloudlet provisioned and tmus farther and > 100km than azure and gcp and azure closer than gcp']
findCloudlet_samsung_tmus_tmusCloserThanGcpLessThan100km.robot
['FindCloudlet Samsung - request shall return tmus with gcp cloudlet provisioned and tmus closer and < 100km from request']
createClusterInstance_openstack_IpAccessDedicated_k8s.robot
['ClusterInst shall create with IpAccessDedicated/K8s and num_masters=1 and num_nodes=1 on openstack', 'ClusterInst shall create with IpAccessDedicated/k8s and num_masters=1 and num_nodes=5 on openstack', 'ClusterInst shall create with IpAccessDedicated/k8s and num_masters=0 and num_nodes=4']
createClusterInstance_openstack_IpAccessDedicated_docker.robot
['ClusterInst shall create with IpAccessDedicated/docker on openstack']
createClusterInstance_openstack_IpAccessDedicated_helm.robot
['ClusterInst shall create with IpAccessDedicated/helm and num_masters=1 and num_nodes=1 on openstack', 'ClusterInst shall create with IpAccessDedicated/helm and num_masters=1 and num_nodes=6 on openstack', 'ClusterInst shall create with IpAccessDedicated/helm and num_masters=0 and num_nodes=4']
create2ClusterInstance_substringName.robot
['CRM shall be able to create 2 clusterInst with one name a substring of the other']
createClusterInstance_openstack_flavors.robot
['Cluster with flavor less than 20g on openstack shall fail with size too small', 'Cluster with vcpus=1 and ram=1024 on openstack shall be m4.small', 'Cluster with vcpus=2 and ram=2048 on openstack shall be m4.small', 'Cluster with vcpus=4 and ram=4096 on openstack shall be sdwan-ESC', 'Cluster with vcpus=4 and ram=8192 and disk=40 on openstack shall be m4.large', 'Cluster with vcpus=8 and ram=16384 and disk=160 on openstack shall be m4.xlarge', 'Cluster with vcpus=1 and ram=8192 and disk=1 on openstack shall be sdwan-ESC', 'Cluster with vcpus=1 and ram=1024 and disk=160 on openstack shall be m4.xlarge', '#Cluster shall create with different master and node flavors on openstack', 'Cluster with vcpus=20 and ram=4096 on openstack shall fail with no flavor found', 'Cluster with vcpus=1 and ram=40960 on openstack shall fail with no flavor found', 'Cluster with vcpus=1 and ram=1024 and disk=1000 on openstack shall fail with no flavor found']
createClusterInstance_openstack_IpAccessDedicated_numNodes.robot
['ClusterInst shall create with IpAccessDedicated and num_nodes=1 on openstack', 'ClusterInst shall create with IpAccessDedicated and num_nodes=3 on openstack', 'ClusterInst shall create with IpAccessDedicated and num_nodes=12 on openstack', 'ClusterInst shall not create with IpAccessDedicated and multiple masters', 'ClusterInst shall create clusterInst with IpAccessDedicated and 0 masters and 4 nodes', 'ClusterInst shall create with IpAccessDedicated and num_masters=0 num_nodes=0 on openstack']
delete_clusterInstance_notExist.robot
['CRM shall be able to create 2 clusterInst with one name a substring of the other']
create2ClusterInstanceSameTime.robot
['CRM shall be able to Create 2 cluster instances at the same time on openstack']
createClusterInstance_mixedCase.robot
['CRM shall be able to create a cluster instances with mixed case clustername for openstack']
createClusterInstance_openstack_numNodes.robot
['Cluster shall create with IpAccessShared and num_nodes=4 on openstack', 'Cluster shall create with IpAccessShared and num_nodes=10 on openstack', 'Cluster shall not create with IpAccessShared and multiple masters', 'Cluster shall not create clusterInst with IpAccessShared and 0 masters']
create2ClusterInstanceSameCloudlet.robot
['CRM shall be able to Create 2 cluster instances on the same cloudlet for openstack']
createClusterInstance_delete_create_sametime.robot
['User shall be able to delete/create an app instance at the same time on openstack']
createClusterInstance_azure_vmsizes.robot
['Cluster with vcpus=1 and ram=1024 on azure shall be Standard_DS1_v2', 'Cluster with vcpus=2 and ram=2048 on azure shall be Standard_DS2_v2', 'Cluster with vcpus=4 and ram=4096 on azure shall be Standard_DS3_v2', 'Cluster with vcpus=1 and num_nodes=4 on azure shall be Standard_DS1_v2', 'Cluster with vcpus=20 and ram=4096 on azure shall fail with quota limit']
createClusterInstance_nameLength.robot
['CRM shall be able to create a cluster instances with 64 chars on openstack', 'CRM shall be able to create a cluster instances with long name on openstack']
fqdn_udptcp_port_openstack_volume_mounts.robot
['User shall be able to access UDP,TCP and HTTP ports on openstack with volume mounts']
fqdn_udptcp_port_gcp.robot
['User shall be able to access 1 UDP port on gcp', 'User shall be able to access 2 UDP ports on azure', 'User shall be able to access 1 TCP port on azure', 'User shall be able to access 2 TCP ports on azure', 'User shall be able to access 2 UDP and 2 TCP ports on azure']
fqdn_udptcp_port_openstack.robot
['User shall be able to access 1 UDP port on openstack', 'User shall be able to access 2 UDP ports on openstack', 'User shall be able to access 1 TCP port on openstack', 'User shall be able to access 2 TCP ports on openstack', 'User shall be able to access 2 UDP and 2 TCP ports on openstack', 'User shall be able to access HTTP port on openstack', 'User shall be able to access UDP,TCP and HTTP ports on openstack', 'User shall be able to access UDP,TCP and HTTP ports on openstack with manifest']
create_appInst_timings.robot
['CreateAppInst on openstack shall create quickly']
fqdn_udptcp_port_azure.robot
['User shall be able to access 1 UDP port on azure', 'User shall be able to access 2 UDP ports on azure', 'User shall be able to access 1 TCP port on azure', 'User shall be able to access 2 TCP ports on azure', 'User shall be able to access 2 UDP and 2 TCP ports on azure']
create_appInst_delete_create_sametime.robot
['User shall be able to delete/create an app instance at the same time on openstack']
create_appInst_reboot.robot
['User shall be able to access UDP,TCP and HTTP ports on openstack after reboot']
fqdn_udptcp_port_openstack_reboot.robot
['User shall be able to access UDP,TCP and HTTP ports on openstack after reboot']
create_app_dot.robot
['User shall be able to create an app instance on openstack with a dot in the app name']
create_app_dot_azure.robot
['User shall be able to create an app instance on azure with a dot in the app name']
fqdn_udptcp_port_openstack_autocluster.robot
['User shall be able to access 2 UDP and 2 TCP ports on openstack and autocluster']
fqdn_udptcp_port_openstack_scale.robot
['User shall be able to access UDP,TCP and HTTP ports on openstack with scaling and num_nodes=1', 'User shall be able to access UDP,TCP and HTTP ports on openstack with scaling and num_nodes=2', 'User shall be able to access UDP,TCP and HTTP ports on openstack with scaling and num_nodes=10']
stats_openstack.robot
['User shall be able to access 1 UDP port on openstack']
create_appInst_manifestFail.robot
['Controller should cleanup autocluster after CreateAppInst fail']
fqdn_udptcp_port_openstack_IpAccessDedicated_docker.robot
['User shall be able to access 1 UDP port on openstack with docker', 'User shall be able to access 1 TCP port on openstack with docker', 'User shall be able to access 2 UDP and 2 TCP ports on openstack with docker']
create_appInst_fail_blockRestAccess.robot
['CRM shall recover when attempting to create an app instance on openstack with rootlb rest port blocked', 'CRM shall recover when attempting to create an app instance with autocluster on openstack with rootlb rest port blocked']
fqdn_udptcp_port_openstack_IpAccessDedicated.robot
['User shall be able to access 1 UDP port on openstack with IpAccessDedicated', 'User shall be able to access 2 UDP ports on openstack with IpAccessDedicated', 'User shall be able to access 1 TCP port on openstack with IpAccessDedicated', 'User shall be able to access 2 TCP ports on openstack with IpAccessDedicated', 'User shall be able to access 2 UDP and 2 TCP ports on openstack with IpAccessDedicated', 'User shall be able to access HTTP port on openstack with IpAccessDedicated', 'User shall be able to access UDP,TCP and HTTP ports on openstack with IpAccessDedicated']
fqdn_udptcp_port_openstack_IpAccessDedicated_docker_compose.robot
['User shall be able to access 2 UDP and 2 TCP ports on openstack with docker compose']
fqdn_udptcp_port_openstack_IpAccessDedicated_volume_mounts.robot
['User shall be able to access UDP and TCP ports on openstack with IpAccessDedicated and volume mounts']
create_appInst_delete_create.robot
['User shall be able to create/delete/create an app instance on openstack']
fqdn_udptcp_port_openstack_IpAccessDedicated_autocluster_docker.robot
['User shall be able to access 2 UDP and 2 TCP ports on openstack with docker and autocluster']
fqdn_udptcp_port_openstack_numMasters1_numNodes0.robot
['User shall be able to access UDP,TCP and HTTP ports on openstack with num_masters=1 and num_nodes=0']
create_clusterInst.robot
['clustersvc shall create/delete MEXPrometheusAppName and MEXMetricsExporter app and app instance']
create_clusterInst_multiple.robot
['clustersvc shall create/delete multiple MEXPrometheusAppName and MEXMetricsExporter app and app instance']
create_clusterInst_openstack.robot
['Create clusterInst for clustersvc on openstack']
clusterSvc_influxdb_clusterInst.robot
['ClusterInst Stats shall be created on openstack', 'Cluster Stats shall be created on azure']
clusterSvc_influxdb_appInst.robot
['AppInst and ClusterInst Stats shall be created on openstack', 'Cluster Stats shall be created on azure']
test_developerAdd_nameOnly.py
['def test_createDeveloper_nameOnly', 'def test_createDeveloper_nameEmptyParms']
test_developerDelete_unknown.py
['def test_DeleteDeveloperUnknown']
test_deleteDeveloper_beforeApp.py
['def test_DeleteDeveloperBeforeApp']
test_developerUpdate_unknown.py
['def test_updateDeveloperUnknown']
test_developerAdd_100.py
['def test_createDeveloper']
test_developerUpdate_change.py
['def test_updateDeveloperNameOnly', 'def test_updateDeveloperSameParms', 'def test_updateDeveloperAllParms', 'def test_updateDeveloperEmail', 'def test_updateDeveloperAddress', 'def test_updateDeveloperUsername', 'def test_updateDeveloperPasshash']
test_developerAdd_sameName.py
['def test_createDeveloper_sameName_allOptional', 'def test_createDeveloper_sameName_nameOnly']
test_developerAdd_nameOptionalParms.py
['def test_createDeveloper_nameAddress', 'def test_createDeveloper_nameEmail', 'def test_createDeveloper_nameUsername', 'def test_createDeveloper_namePasshash', 'def test_createDeveloper_nameAllOptional']
test_developerAdd_multiControllers.py
['def test_createDeveloper']
test_developerAdd_noName.py
['def test_createDeveloperEmptyName', 'def test_createDeveloperNoName']
test_developerDelete.py
['def test_deleteDeveloper']
test_developerUpdate_add.py
['def test_updateDeveloperAddAllParms', 'def test_updateDeveloperAddEmail', 'def test_updateDeveloperAddAddress', 'def test_updateDeveloperAddUsername', 'def test_updateDeveloperAddPasshash']
test_developerShow_single.py
['def test_showDeveloper_nameOnly']
test_developerAdd_invalidName.py
['def test_createDeveloperStartUnderscore', 'def test_createDeveloperParenthesis', 'def test_createDeveloperDollarsign', 'def test_createDeveloperOtherInvalidChars']
test_clusterDelete_nameNotFound.py
['def test_DeleteClusterNameNotFound', '    def test_DeleteClusterNameNotFound(self):']
test_clusterAdd_AutoCluster.py
['def test_AddAutoCluster', '    def test_AddAutoCluster(self):']
test_clusterAdd_noDefaultFlavor.py
['def test_GetCloudlets', '    def test_GetCloudlets(self):']
test_clusterInstUpdate_notSupported.py
['def test_UpdateClusterInst', '    def test_UpdateClusterInst(self):']
test_clusterDelete_beforeApp.py
['def test_DeleteClusterBeforeApp', '    def test_DeleteClusterBeforeApp(self):']
test_clusterInstDelete.py
['def test_DeleteClusterInstanceFlavor', 'def test_DeleteClusterInstanceNoFlavor', '    def test_DeleteClusterInstanceFlavor(self):', '    def test_DeleteClusterInstanceNoFlavor(self):']
test_clusterInstAdd_100.py
['def test_AddClusterInstance', '    def test_AddClusterInstance(self):']
test_clusterDelete_invalidName.py
['def test_DeleteClusterUnderscore', 'def test_DeleteClusterInvalidChars', '    def test_DeleteClusterUnderscore(self):', '    def test_DeleteClusterInvalidChars(self):']
test_clusterInstDelete_notFound.py
['def test_DeleteClusterNameOnly', 'def test_DeleteClusterNoFlavor', 'def test_DeleteClusterNoName', '    def test_DeleteClusterNameOnly(self):', '    def test_DeleteClusterNoFlavor(self):', '    def test_DeleteClusterNoName(self):']
test_clusterInstAdd_noFlavor.py
['def test_NoFlavor', 'def test_EmptyFlavor', '    def test_NoFlavor(self):', '    def test_EmptyFlavor(self):']
test_clusterDelete_beforeClusterInst.py
['def test_DeleteClusterBeforeClusterInstance', '    def test_DeleteClusterBeforeClusterInstance(self):']
test_clusterInstAdd_flavorNotExist.py
['def test_NoFlavor', '    def test_NoFlavor(self):']
test_clusterAdd_defaultFlavor.py
['def test_createClusterDefaultFlavor', '    def test_createClusterDefaultFlavor(self):']
clusterInstAdd_ipaccess.robot
['CreateClusterInst - creating cluster inst with ipaccess=IpAccessUnknown shall set to IpAccessShared', 'CreateClusterInst - shall be to create a clusterInst with ipaccess=IpAccessShared', 'CreateClusterInst - shall be to create a clusterInst with ipaccess=IpAccessDedicated', 'CreateClusterInst - shall be to create a clusterInst with ipaccess=IpAccessDedicatedOrShared', 'CreateClusterInst - shall be to create a azure clusterInst with ipaccess=IpAccessDedicatedOrShared', 'CreateClusterInst - shall be to create a azure clusterInst with ipaccess=IpAccessDedicated', 'CreateClusterInst - shall be to create a azure clusterInst with ipaccess=IpAccessShared', 'CreateClusterInst - shall be to create a azure clusterInst with ipaccess=IpAccessUnknown', 'CreateClusterInst - shall be to create a gcp clusterInst with ipaccess=IpAccessDedicatedOrShared', 'CreateClusterInst - shall be to create a gcp clusterInst with ipaccess=IpAccessDedicated', 'CreateClusterInst - shall be to create a gcp clusterInst with ipaccess=IpAccessShared', 'CreateClusterInst - shall be to create a gcp clusterInst with ipaccess=IpAccessUnknown', 'CreateClusterInst - shall be to create a clusterInst with ipaccess=IpAccessUnknown and deployment=docker', 'CreateClusterInst - shall not be to create a clusterInst with ipaccess=IpAccessShared and deployment=docker', 'CreateClusterInst - shall not be to create a clusterInst with ipaccess=IpAccessDedicatedOrShared and deployment=docker']
test_clusterAdd_InvalidClusterName.py
['def test_AddClusterUnderscore', 'def test_AddClusterSpecialChars', 'def test_AddClusterStartDash', '    def test_AddClusterUnderscore(self):', '    def test_AddClusterSpecialChars(self):', '    def test_AddClusterStartDash(self):']
test_clusterAdd_defaultFlavorNotExist.py
['def test_CreateClusterFlavorNotFound', '    def test_CreateClusterFlavorNotFound(self):']
test_clusterInstAddMultiControllers.py
['def test_AddClusterInstance']
test_clusterInstAdd_cloudletInfoNotFound.py
['def test_CreateClusterInstCloudletNotFound', '    def test_CreateClusterInstCloudletNotFound(self):']
test_clusterInstAdd_operatorNotMatchCloudlet.py
['def test_OperatorNotMatchCloudlet', '    def test_OperatorNotMatchCloudlet(self):']
test_clusterInstAdd_clusterNotFound.py
['def test_CreateClusterInstNoCluster', '    def test_CreateClusterInstNoCluster(self):']
test_clusterInstDelete_beforeAppInst.py
['def test_DeleteClusterBeforeApp', '    def test_DeleteClusterBeforeApp(self):']
test_clusterAdd_noName.py
['def test_AddClusterWithNoName', 'def test_AddClusterWithNoNameNoDefaultFlavor', '    def test_AddClusterWithNoName(self):', '    def test_AddClusterWithNoNameNoDefaultFlavor(self):']
test_clusterInstAdd_liveness1.py
['def test_AddClusterInstance', '    def test_AddClusterInstance(self):']
clusterInstAdd_ipaccessDedicated.robot
['CreateClusterInst - create a clusterinst with ipaccess=IpAccessDedicated and no deployment shall default to kubernetes', 'CreateClusterInst - shall be able to create a clusterinst with ipaccess=IpAccessDedicated and deployment=kubernetes', 'CreateClusterInst - create a clusterinst with ipaccess=IpAccessDedicated and deployment=helm shall default to kubernetes', 'CreateClusterInst - shall not be able to create a clusterinst with ipaccess=IpAccessDedicated and deployment=vm', 'CreateClusterInst - shall be not able to create a clusterinst with ipaccess=IpAccessDedicated and deployment=docker num_masters=0 num_nodes=1', 'CreateClusterInst - shall be not able to create a clusterinst with ipaccess=IpAccessDedicated and deployment=docker num_masters=1 num_nodes=0', 'CreateClusterInst - shall be not able to create a clusterinst with ipaccess=IpAccessDedicated and deployment=docker num_masters=1 num_nodes=1', 'CreateClusterInst - shall be able to create a clusterinst with ipaccess=IpAccessDedicated and deployment=docker num_masters=0 num_nodes=0', 'CreateClusterInst - shall not create with IpAccessDedicated/kubernetes and multiple masters', 'CreateClusterInst - shall not create with IpAccessDedicated/kubernetes and num_masters=0 num_nodes=0', 'CreateClusterInst - shall not create with IpAccessDedicated/kubernetes and num_masters=1 num_nodes=0', 'CreateClusterInst - shall not create with IpAccessDedicated and invalid deployment']
test_clusterInstAdd.py
['def test_AddClusterInstance', '    def test_AddClusterInstance(self):']
test_clusterInstAdd_liveness2.py
['def test_AddClusterInstance', '    def test_AddClusterInstance(self):']
test_clusterUpdate_notSupported.py
['def test_UpdateCluster', '    def test_UpdateCluster(self):']
test_clusterAddMultiControllers.py
['def test_AddClusterInstance']
test_clusterInstAdd_keyExists.py
['def test_CreateClusterTwice', '    def test_CreateClusterTwice(self):']
test_clusterInstAdd_missingParms.py
['def test_CreateClusterInstFlavorOnly', 'def test_CreateClusterInstOperatorOnly', 'def test_CreateClusterInstCloudletNameOnly', 'def test_CreateClusterInstClusterNameOnly', 'def test_CreateClusterInstNoParms', 'def test_CreateClusterInstNoDeveloper', '    def test_CreateClusterInstFlavorOnly(self):', '    def test_CreateClusterInstOperatorOnly(self):', '    def test_CreateClusterInstCloudletNameOnly(self):', '    def test_CreateClusterInstClusterNameOnly(self):', '    def test_CreateClusterInstNoParms(self):', '    def test_CreateClusterInstNoDeveloper(self):']
test_clusterAdd_100.py
['def test_AddMultpleClusters', '    def test_AddMultpleClusters(self):']
test_clusterDelete_noName.py
['def test_DeleteClusterNoName', '    def test_DeleteClusterNoName(self):']
test_clusterInstAdd_noDefaultFlavor_noFlavor.py
['def test_NoFlavor', 'def test_EmptyFlavor', '    def test_NoFlavor(self):', '    def test_EmptyFlavor(self):']
test_appInstAdd_appNotFound.py
['def test_CreateAppInstAppNotFound_nodata', 'def test_CreateAppInstAppNotFound_idonly', 'def test_CreateAppInstAppNotFound_appnameonly', 'def test_CreateAppInstAppNotFound_versiononly', 'def test_CreateAppInstAppNotFound_developeronly', 'def test_CreateAppInstAppNotFound_nameVersionDeveloperonly', '    def test_CreateAppInstAppNotFound_nodata(self):', '    def test_CreateAppInstAppNotFound_idonly(self):', '    def test_CreateAppInstAppNotFound_appnameonly(self):', '    def test_CreateAppInstAppNotFound_versiononly(self):', '    def test_CreateAppInstAppNotFound_developeronly(self):', '    def test_CreateAppInstAppNotFound_nameVersionDeveloperonly(self):']
test_appAdd_qcow.py
['def test_CreateAppQCOWNoImagePath', 'def test_CreateAppQCOWEmptyImagePath', '    def test_CreateAppQCOWNoImagePath(self):', '    def test_CreateAppQCOWEmptyImagePath(self):']
test_appAdd_IpAccessDedicatedPortMulti.py
['def test_CreateAppDockerIpAccessDedicatedTCP2Ports', 'def test_CreateAppDockerIpAccessDedicatedTCP10Ports', 'def test_CreateAppDockerIpAccessDedicatedTCP100Ports', 'def test_CreateAppDockerIpAccessDedicatedTCPUDPPorts', 'def test_CreateAppDockerIpAccessDedicatedHTTP2Ports', 'def test_CreateAppDockerIpAccessDedicatedHTTP10Ports', 'def test_CreateAppDockerIpAccessDedicatedHTTP100Ports', 'def test_CreateAppDockerIpAccessDedicatedTCPUDPHTTPPorts', 'def test_CreateAppDockerIpAccessDedicatedUDP2Ports', 'def test_CreateAppDockerIpAccessDedicatedUDP10Ports', 'def test_CreateAppDockerIpAccessDedicatedUDP100Ports', 'def test_CreateAppQCOWIpAccessDedicatedTCP2Ports', 'def test_CreateAppQCOWIpAccessDedicatedTCP10Ports', 'def test_CreateAppQCOWIpAccessDedicatedTCP100Ports', 'def test_CreateAppQCOWIpAccessDedicatedTCPUDPPorts', 'def test_CreateAppQCOWIpAccessDedicatedHTTP2Ports', 'def test_CreateAppQCOWIpAccessDedicatedHTTP10Ports', 'def test_CreateAppQCOWIpAccessDedicatedHTTP100Ports', 'def test_CreateAppQCOWIpAccessDedicatedTCPUDPHTTPPorts', 'def test_CreateAppQCOWIpAccessDedicatedUDP2Ports', 'def test_CreateAppQCOWIpAccessDedicatedUDP10Ports', 'def test_CreateAppQCOWIpAccessDedicatedUDP100Ports', '    def test_CreateAppDockerIpAccessDedicatedTCP2Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedTCP10Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedTCP100Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedTCPUDPPorts(self):', '    def test_CreateAppDockerIpAccessDedicatedHTTP2Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedHTTP10Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedHTTP100Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedTCPUDPHTTPPorts(self):', '    def test_CreateAppDockerIpAccessDedicatedUDP2Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedUDP10Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedUDP100Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCP2Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCP10Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCP100Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCPUDPPorts(self):', '    def test_CreateAppQCOWIpAccessDedicatedHTTP2Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedHTTP10Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedHTTP100Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCPUDPHTTPPorts(self):', '    def test_CreateAppQCOWIpAccessDedicatedUDP2Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedUDP10Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedUDP100Ports(self):']
createApp_manifest.robot
['CreateApp - error shall be received with ImageTypeQCOW and no manifest md5', 'CreateApp - error shall be received wih ImageTypeQCOW and manifest md5 too short', 'CreateApp - error shall be received wih ImageTypeQCOW and manifest md5 invalid ']
createAppInst_developerMismatch.robot
['AppInst - User shall not be able to create an AppInst with a developer mismatch with ClusterInst Developer']
test_appAdd_IpAccessSharedPort65535.py
['def test_CreateAppDockerIpAccessSharedTCP65535', 'def test_CreateAppDockerIpAccessSharedTCP065535', 'def test_CreateAppDockerIpAccessSharedUDP65535', 'def test_CreateAppDockerIpAccessSharedUDP065535', 'def test_CreateAppDockerIpAccessSharedHTTP65535', 'def test_CreateAppDockerIpAccessSharedHTTP065535', 'def test_CreateAppQCOWIpAccessSharedTCP65535', 'def test_CreateAppQCOWIpAccessSharedTCP065535', 'def test_CreateAppQCOWIpAccessSharedUDP65535', 'def test_CreateAppQCOWIpAccessSharedUDP065535', 'def test_CreateAppQCOWIpAccessSharedHTTP65535', 'def test_CreateAppQCOWIpAccessSharedHTTP065535', '    def test_CreateAppDockerIpAccessSharedTCP65535(self):', '    def test_CreateAppDockerIpAccessSharedTCP065535(self):', '    def test_CreateAppDockerIpAccessSharedUDP65535(self):', '    def test_CreateAppDockerIpAccessSharedUDP065535(self):', '    def test_CreateAppDockerIpAccessSharedHTTP65535(self):', '    def test_CreateAppDockerIpAccessSharedHTTP065535(self):', '    def test_CreateAppQCOWIpAccessSharedTCP65535(self):', '    def test_CreateAppQCOWIpAccessSharedTCP065535(self):', '    def test_CreateAppQCOWIpAccessSharedUDP65535(self):', '    def test_CreateAppQCOWIpAccessSharedUDP065535(self):', '    def test_CreateAppQCOWIpAccessSharedHTTP65535(self):', '    def test_CreateAppQCOWIpAccessSharedHTTP065535(self):']
createApp_deployementDocker.robot
['CreateApp - error shall be received with image_type=ImageTypeDocker deployment=docker and access_ports=http', 'CreateApp - error shall be received with image_type=ImageTypeDocker deployment=docker and access_ports=tcp,udp,http']
createAppInst_noClusterInst.robot
['AppInst - User shall not be able to create an AppInst without a ClusterInst', 'AppInst - User shall not be able to create an AppInst with a ClusterInst that doesnt exist', 'AppInst - User shall not be able to create an app instance without cluster developer and no matching cluster instance']
test_appAdd_defaultFlavorNotFound.py
['def test_CreateAppDefaultFlavorNotFound_Docker', 'def test_CreateAppDefaultFlavorNotFound_QCOW', '    def test_CreateAppDefaultFlavorNotFound_Docker(self):', '    def test_CreateAppDefaultFlavorNotFound_QCOW(self):']
test_appDelete_appInstExists.py
['def test_DeleteApp_appInstance_exists', '    def test_DeleteApp_appInstance_exists(self):']
createAppInst_2autocluster.robot
['AppInst - Shall be able to create to AppInsts with autocluster on the same app with different developer ']
test_appAdd_invalidImageType.py
['def test_CreateInvalidImageType', '    def test_CreateInvalidImageType(self):']
test_appAdd_noIpAccess.py
['def test_CreateAppDockerNoAccessLayer', 'def test_CreateAppQCOWNoAccessLayer', '    def test_CreateAppDockerNoAccessLayer(self):', '    def test_CreateAppQCOWNoAccessLayer(self):']
test_appAdd_appNameEmpty.py
['def test_CreateAppNameEmpty', 'def test_CreateAppNameMissing', '    def test_CreateAppNameEmpty(self):', '    def test_CreateAppNameMissing(self):']
test_appAdd_developerNotFound.py
['def test_CreateAppDeveloperNotFound_Docker', 'def test_CreateAppDeveloperNotFound_QCOW', '    def test_CreateAppDeveloperNotFound_Docker(self):', '    def test_CreateAppDeveloperNotFound_QCOW(self):']
test_appAdd_portOutOfRange.py
['def test_CreateAppPortRangeDedicated_1', 'def test_CreateAppPortRangeDedicated_2', 'def test_CreateAppPortRangeDedicated_3', 'def test_CreateAppPortRangeDedicated_4', ' def test_CreateAppPortRangeDedicatedShared_1', ' def test_CreateAppPortRangeDedicateShared_2', ' def test_CreateAppPortRangeDedicatedShared_3', ' def test_CreateAppPortRangeDedicatedShared_4', '    def test_CreateAppPortRangeDedicated_1(self):', '    def test_CreateAppPortRangeDedicated_2(self):', '    def test_CreateAppPortRangeDedicated_3(self):', '    def test_CreateAppPortRangeDedicated_4(self):', '#    def test_CreateAppPortRangeDedicatedShared_1(self):', '#    def test_CreateAppPortRangeDedicateShared_2(self):', '#    def test_CreateAppPortRangeDedicatedShared_3(self):', '#    def test_CreateAppPortRangeDedicatedShared_4(self):']
updateApp_fqdn.robot
['CreateAppInst - autocluster shall be created when app instance is created without clustername', 'AppInst - User shall be able to update the app accessports afer appInst delete']
test_appAdd_100.py
['def test_CreateApp100', '    def test_CreateApp100(self):']
test_appAdd_invalidIpAccess.py
['def test_CreateInvalidIpaccess', '    def test_CreateInvalidIpaccess(self):']
test_appAdd_IpAccessDedicatedPort1.py
['def test_CreateAppDockerIpAccessDedicatedTCP1', 'def test_CreateAppDockerIpAccessDedicatedTCP01', 'def test_CreateAppDockerIpAccessDedicatedHTTP1', 'def test_CreateAppDockerIpAccessDedicatedHTTP01', 'def test_CreateAppDockerIpAccessDedicatedUDP1', 'def test_CreateAppDockerIpAccessDedicatedUDP01', 'def test_CreateAppQCOWIpAccessDedicatedTCP1', 'def test_CreateAppQCOWIpAccessDedicatedTCP01', 'def test_CreateAppQCOWIpAccessDedicatedUDP1', 'def test_CreateAppQCOWIpAccessDedicatedUDP01', 'def test_CreateAppQCOWIpAccessDedicatedHTTP1', 'def test_CreateAppQCOWIpAccessDedicatedHTTP01', '    def test_CreateAppDockerIpAccessDedicatedTCP1(self):', '    def test_CreateAppDockerIpAccessDedicatedTCP01(self):', '    def test_CreateAppDockerIpAccessDedicatedHTTP1(self):', '    def test_CreateAppDockerIpAccessDedicatedHTTP01(self):', '    def test_CreateAppDockerIpAccessDedicatedUDP1(self):', '    def test_CreateAppDockerIpAccessDedicatedUDP01(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCP1(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCP01(self):', '    def test_CreateAppQCOWIpAccessDedicatedUDP1(self):', '    def test_CreateAppQCOWIpAccessDedicatedUDP01(self):', '    def test_CreateAppQCOWIpAccessDedicatedHTTP1(self):', '    def test_CreateAppQCOWIpAccessDedicatedHTTP01(self):']
test_appAdd_IpAccessDedicatedOrSharedMulti.py
['def test_CreateAppDockerIpAccessDedicatedOrSharedTCP2Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedTCP10Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedTCP100Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedTCPUDPPorts', 'def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP2Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP10Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP100Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedTCPUDPHTTPPorts', 'def test_CreateAppDockerIpAccessDedicatedOrSharedUDP2Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedUDP10Ports', 'def test_CreateAppDockerIpAccessDedicatedOrSharedUDP100Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP2Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP10Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP100Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCPUDPPorts', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP2Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP10Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP100Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP2Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP10Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP100Ports', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCPUDPHTTPPorts', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCP2Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCP10Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCP100Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCPUDPPorts(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP2Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP10Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP100Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCPUDPHTTPPorts(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedUDP2Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedUDP10Ports(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedUDP100Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP2Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP10Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP100Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCPUDPPorts(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP2Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP10Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP100Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP2Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP10Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP100Ports(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCPUDPHTTPPorts(self):']
test_appAdd_keyExists.py
['def test_CreateAppDockerKeyExists', 'def test_CreateAppDockerKeyExists_2', '    def test_CreateAppDockerKeyExists(self):', '    def test_CreateAppDockerKeyExists_2(self):']
createAppInst_publicPort_tcp.robot
['AppInst - user shall be able to add 1 TCP port with same public port', 'AppInst - user shall be able to add 10 TCP port with same public port', 'AppInst - user shall be able to add TCP and UDP ports with the same port numbers', 'AppInst - 2 appInst on different app and same cluster and same cloudlet shall not be able to allocate the same public TCP port', 'AppInst - 2 appInst on different app and different cluster and same cloudlet shall not be able to allocate the same public TCP port', 'AppInst - 2 appInst on different app/cluster/cloudlet shall be able to allocate the same public TCP port', 'AppInst - 2 appInst on same app and different cluster and same cloudlet shall not be able to allocate the same public TCP port', 'AppInst - 2 appInst on same app and different cluster and different cloudlet shall not be able to allocate the same public TCP port', 'AppInst - User shall be able to add app/appInst, delete, and readd with same public TCP port', 'AppInst - User shall be able to add app, udpate app, add /appInst with same public TCP port', 'AppInst - 3 appInst on different app and different cluster and different cloudlet shall not be able to allocate public TCP port 10000', 'AppInst - appInst shall not allocate TCP port 10000 if already allocated', 'AppInst - user shall be to add multiple TCP public ports', 'AppInst - user shall not be able to allocate public port tcp:22', 'AppInst - user shall be able to allocate public port tcp:18889', 'AppInst - user shall be able to allocate public port tcp:18888']
test_appAdd_emptyCluster.py
['def test_CreateAppNoCluster', 'def test_CreateAppEmptyCluster', '    def test_CreateAppNoCluster(self):', '    def test_CreateAppEmptyCluster(self):']
test_appAdd_IpAccessSharedPort1.py
['def test_CreateAppDockerIpAccessSharedTCP1', 'def test_CreateAppDockerIpAccessSharedTCP01', 'def test_CreateAppDockerIpAccessSharedUDP1', 'def test_CreateAppDockerIpAccessSharedUDP01', 'def test_CreateAppDockerIpAccessSharedHTTP1', 'def test_CreateAppDockerIpAccessSharedHTTP01', 'def test_CreateAppQCOWIpAccessSharedTCP1', 'def test_CreateAppQCOWIpAccessSharedTCP01', 'def test_CreateAppQCOWIpAccessSharedUDP1', 'def test_CreateAppQCOWIpAccessSharedUDP01', 'def test_CreateAppQCOWIpAccessSharedHTTP1', 'def test_CreateAppQCOWIpAccessSharedHTTP01', 'def test_CreateAppQCOWIpAccessSharedHTTPUppercase', '    def test_CreateAppDockerIpAccessSharedTCP1(self):', '    def test_CreateAppDockerIpAccessSharedTCP01(self):', '    def test_CreateAppDockerIpAccessSharedUDP1(self):', '    def test_CreateAppDockerIpAccessSharedUDP01(self):', '    def test_CreateAppDockerIpAccessSharedHTTP1(self):', '    def test_CreateAppDockerIpAccessSharedHTTP01(self):', '    def test_CreateAppQCOWIpAccessSharedTCP1(self):', '    def test_CreateAppQCOWIpAccessSharedTCP01(self):', '    def test_CreateAppQCOWIpAccessSharedUDP1(self):', '    def test_CreateAppQCOWIpAccessSharedUDP01(self):', '    def test_CreateAppQCOWIpAccessSharedHTTP1(self):', '    def test_CreateAppQCOWIpAccessSharedHTTP01(self):', '    def test_CreateAppQCOWIpAccessSharedHTTPUppercase(self):']
test_appAdd_flavorNotFound.py
['def test_CreateAppImageTypeOnlyImageTypeUnknown', '    def test_CreateAppImageTypeOnlyImageTypeUnknown(self):']
test_appAdd_invalidPortFormat.py
['def test_CreateAppInvalidFormatIpAccessDedicated_1', 'def test_CreateAppInvalidFormatIpAccessDedicated_2', 'def test_CreateAppInvalidFormatIpAccessDedicated_3', 'def test_CreateAppInvalidFormatIpAccessDedicated_4', 'def test_CreateAppInvalidFormatIpAccessDedicated_5', 'def test_CreateAppInvalidFormatIpAccessDedicated_6', 'def test_CreateAppInvalidFormatIpAccessDedicated_7', ' def test_CreateAppInvalidFormatlIpAccessDedicatedOrShared_1', ' def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_2', ' def test_CreateAppInvalidFormaIpAccessDedicatedOrShared_3', ' def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_4', ' def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_5', ' def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_6', ' def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_7', ' def test_CreateAppInvalidFormatlIpAccessShared_1', ' def test_CreateAppInvalidFormatIpAccessShared_2', ' def test_CreateAppInvalidFormaIpAccessShared_3', ' def test_CreateAppInvalidFormatIpAccessShared_4', ' def test_CreateAppInvalidFormatIpAccessShared_5', ' def test_CreateAppInvalidFormatIpAccessShared_6', ' def test_CreateAppInvalidFormatIpAccessShared_7', '    def test_CreateAppInvalidFormatIpAccessDedicated_1(self):', '    def test_CreateAppInvalidFormatIpAccessDedicated_2(self):', '    def test_CreateAppInvalidFormatIpAccessDedicated_3(self):', '    def test_CreateAppInvalidFormatIpAccessDedicated_4(self):', '    def test_CreateAppInvalidFormatIpAccessDedicated_5(self):', '    def test_CreateAppInvalidFormatIpAccessDedicated_6(self):', '    def test_CreateAppInvalidFormatIpAccessDedicated_7(self):', '#    def test_CreateAppInvalidFormatlIpAccessDedicatedOrShared_1(self):', '#    def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_2(self):', '#    def test_CreateAppInvalidFormaIpAccessDedicatedOrShared_3(self):', '#    def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_4(self):', '#    def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_5(self):', '#    def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_6(self):', '#    def test_CreateAppInvalidFormatIpAccessDedicatedOrShared_7(self):', '#    def test_CreateAppInvalidFormatlIpAccessShared_1(self):', '#    def test_CreateAppInvalidFormatIpAccessShared_2(self):', '#    def test_CreateAppInvalidFormaIpAccessShared_3(self):', '#    def test_CreateAppInvalidFormatIpAccessShared_4(self):', '#    def test_CreateAppInvalidFormatIpAccessShared_5(self):', '#    def test_CreateAppInvalidFormatIpAccessShared_6(self):', '#    def test_CreateAppInvalidFormatIpAccessShared_7(self):']
test_appAdd_config_invalid.py
['def test_CreateAppDockerConfig_inlineInvalid', 'def test_CreateAppDockerConfig_httpInvalid', '    def test_CreateAppDockerConfig_inlineInvalid(self):', '    def test_CreateAppDockerConfig_httpInvalid(self):']
createAppInst_fqdnprefix.robot
['AppInst - user shall be able to add 1 TCP port with same public port', 'AppInst - user shall be able to add 10 TCP port with same public port', 'AppInst - user shall be able to add TCP and UDP ports with the same port numbers', 'AppInst - 2 appInst on different app and same cluster and same cloudlet shall not be able to allocate the same public TCP port', 'AppInst - 2 appInst on different app and different cluster and same cloudlet shall not be able to allocate the same public TCP port', 'AppInst - 2 appInst on different app/cluster/cloudlet shall be able to allocate the same public TCP port', 'AppInst - 2 appInst on same app and different cluster and same cloudlet shall not be able to allocate the same public TCP port', 'AppInst - 2 appInst on same app and different cluster and different cloudlet shall not be able to allocate the same public TCP port', 'AppInst - User shall be able to add app/appInst, delete, and readd with same public TCP port', 'AppInst - User shall be able to add app, udpate app, add /appInst with same public TCP port', 'AppInst - 3 appInst on different app and different cluster and different cloudlet shall not be able to allocate public TCP port 10000', 'AppInst - appInst shall not allocate TCP port 10000 if already allocated', 'AppInst - user shall be to add multiple TCP public ports', 'AppInst - user shall not be able to allocate public port tcp:22', 'AppInst - user shall be able to allocate public port tcp:18889', 'AppInst - user shall be able to allocate public port tcp:18888']
test_appAdd_imageTypeOnly.py
['def test_CreateAppImageTypeOnlyImageTypeUnknown', 'def test_CreateAppImageTypeOnlyImageTypeDocker', 'def test_CreateAppImageTypeOnlyImageTypeQCOW', 'def test_CreateAppImageTypeOnlyImageTypeWrong', '    def test_CreateAppImageTypeOnlyImageTypeUnknown(self):', '    def test_CreateAppImageTypeOnlyImageTypeDocker(self):', '    def test_CreateAppImageTypeOnlyImageTypeQCOW(self):', '    def test_CreateAppImageTypeOnlyImageTypeWrong(self):']
createAppInst.robot
["AppInst - autocluster shall be created when app instance is created with clustername='autocluster'", "AppInst - autocluster shall be created when app instance is created with clustername='autocluster' and no developer", 'AppInst - appinst shall be created when app instance is created without cluster developer', 'AppInst - appinst shall be created when app instance is created with auto-cluster and autoclusteripaccess=IpAccessDedicated', 'AppInst - appinst shall be created when app instance is created with auto-cluster and autoclusteripaccess=IpAccessShared', 'AppInst - appinst shall be created when app instance is created with auto-cluster and autoclusteripaccess=IpAccessDedicatedOrShared']
test_appAdd_IpAccessDedicatedOrSharedPort65535.py
['def test_CreateAppDockerIpAccessDedicatedOrSharedTCP65535', 'def test_CreateAppDockerIpAccessDedicatedOrSharedTCP065535', 'def test_CreateAppDockerIpAccessDedicatedOrSharedUDP65535', 'def test_CreateAppDockerIpAccessDedicatedOrSharedUDP065535', 'def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP65535', 'def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP065535', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP65535', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP065535', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP65535', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP065535', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP65535', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP065535', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCP65535(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCP065535(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedUDP65535(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedUDP065535(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP65535(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP065535(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP65535(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP065535(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP65535(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP065535(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP65535(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP065535(self):']
test_appAdd_IpAccessDedicatedOrSharedPort1.py
['def test_CreateAppDockerIpAccessDedicatedOrSharedTCP1', 'def test_CreateAppDockerIpAccessDedicatedOrSharedTCP01', 'def test_CreateAppDockerIpAccessDedicatedOrSharedUDP1', 'def test_CreateAppDockerIpAccessDedicatedOrSharedUDP01', 'def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP1', 'def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP01', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP1', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP01', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP1', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP01', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP1', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP01', 'def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTPUppercase', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCP1(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedTCP01(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedUDP1(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedUDP01(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP1(self):', '    def test_CreateAppDockerIpAccessDedicatedOrSharedHTTP01(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP1(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedTCP01(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP1(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedUDP01(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP1(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTP01(self):', '    def test_CreateAppQCOWIpAccessDedicatedOrSharedHTTPUppercase(self):']
updateApp_manifest.robot
['UpdateApp - user shall be able to update the manifest']
test_appAdd_appNameInvalid.py
['def test_CreateNameAtSymbol', 'def test_CreateNameStartUnderscore', 'def test_CreateNameParenthesis', '    def test_CreateNameAtSymbol(self):', '    def test_CreateNameStartUnderscore(self):', '    def test_CreateNameParenthesis(self):']
createAppInst_publicPort_http.robot
['AppInst - user shall be able to add 1 HTTP port', 'AppInst - user shall be able to add 10 HTTP ports', 'AppInst - 2 appInst on different app and same cluster and same cloudlet shall be able to allocate the same HTTP port', 'AppInst - 2 appInst on different app and different cluster and same cloudlet shall be able to allocate the same HTTP port', 'AppInst - 2 appInst on different app/cluster/cloudlet shall be able to allocate the same HTTP port', 'AppInst - 2 appInst on same app and different cluster and same cloudlet shall be able to allocate the same HTTP port', 'AppInst - 2 appInst on same app and different cluster and different cloudlet shall be able to allocate the same public HTTP port', 'AppInst - User shall be able to add app/appInst, delete, and readd with same HTTP port', 'AppInst - User shall be able to add app, udpate app, add appInst with same HTTP port', 'AppInst - 3 appInst on different app and different cluster and different cloudlet shall be able to allocate HTTP port 10000', 'AppInst - appInst shall allocate HTTP port 10000 if already allocated', 'AppInst - user shall be to add multiple HTTP public ports', 'AppInst - user shall be able to allocate port http:22', 'AppInst - user shall be able to allocate port http:18889', 'AppInst - user shall be able to allocate port http:18888']
test_appInstAdd_cloudletNotFound.py
['def test_CreateAppInstCloudletNotFound_nodata', 'def test_CreateAppInstCloudletNotFound_idonly', 'def test_CreateAppInstCloudletNotFound_appnameonly', 'def test_CreateAppInstCloudletNotFound_versiononly', 'def test_CreateAppInstCloudletNotFound_developeronly', 'def test_CreateAppInstCloudletNotFound_nameVesrsionDeveloperonly', 'def test_CreateAppInstCloudletNotFound_cloudletNotFound', 'def test_CreateAppInstCloudletNotFound_noCloudlet', 'def test_CreateAppInstCloudletNotFound_cloudletNameOnly', '    def test_CreateAppInstCloudletNotFound_nodata(self):', '    def test_CreateAppInstCloudletNotFound_idonly(self):', '    def test_CreateAppInstCloudletNotFound_appnameonly(self):', '    def test_CreateAppInstCloudletNotFound_versiononly(self):', '    def test_CreateAppInstCloudletNotFound_developeronly(self):', '    def test_CreateAppInstCloudletNotFound_nameVesrsionDeveloperonly(self):', '    def test_CreateAppInstCloudletNotFound_cloudletNotFound(self):', '    def test_CreateAppInstCloudletNotFound_noCloudlet(self):', '    def test_CreateAppInstCloudletNotFound_cloudletNameOnly(self):']
test_appShow_queryParms.py
['def test_QueryAppName', 'def test_QueryDeveloperName', 'def test_QueryAppNameVersion', '    def test_QueryAppName(self):', '    def test_QueryDeveloperName(self):', '    def test_QueryAppNameVersion(self):']
test_appAdd_clusterNotFound.py
['def test_CreateAppClusterNotFound_docker', 'def test_CreateAppClusterNotFound_qcow', '    def test_CreateAppClusterNotFound_docker(self):', '    def test_CreateAppClusterNotFound_qcow(self):']
test_appAdd_imagePath.py
['def test_CreateAppDockerImagePath', 'def test_CreateAppQCOWImagePath', '    def test_CreateAppDockerImagePath(self):', '    def test_CreateAppQCOWImagePath(self):']
test_appAdd_config.py
['def test_CreateAppDockerConfig_inline', 'def test_CreateAppQCOWConfig', 'def test_CreateAppDockerConfig_http', 'def test_CreateAppQCOWConfig_http', '    def test_CreateAppDockerConfig_inline(self):', '    def test_CreateAppQCOWConfig(self):', '    def test_CreateAppDockerConfig_http(self):', '    def test_CreateAppQCOWConfig_http(self):']
createAppInst_publicPort_udp.robot
['AppInst - user shall be able to add 1 UDP port with same public port', 'AppInst - user shall be able to add 10 UDP port with same public port', 'AppInst - 2 appInst on different app and same cluster and same cloudlet shall not be able to allocate the same public UDP port', 'AppInst - 2 appInst on different app and different cluster and same cloudlet shall not be able to allocate the same public UDP port', 'AppInst - 2 appInst on different app/cluster/cloudlet shall be able to allocate the same public UDP port', 'AppInst - 2 appInst on same app and different cluster and same cloudlet shall not be able to allocate the same public UDP port', 'AppInst - 2 appInst on same app and different cluster and different cloudlet shall not be able to allocate the same public UDP port', 'AppInst - User shall be able to add app/appInst, delete, and readd with same public UDP port', 'AppInst - User shall be able to add app, udpate app, add /appInst with same public UDP port', 'AppInst - 3 appInst on different app and different cluster and different cloudlet shall not be able to allocate public UDP port 10000', 'AppInst - appInst shall not allocate UDP port 10000 if already allocated', 'AppInst - user shall be to add multiple UDP public ports', 'AppInst - user shall not be able to allocate public port udp:22', 'AppInst - user shall be able to allocate public port udp:18889', 'AppInst - user shall be able to allocate public port udp:18888']
test_appAdd_dockerCompliant.py
['def test_CreateNameSpace', 'def test_CreateAndSymbol', 'def test_CreateComma', 'def test_CreateBang', '    def test_CreateNameSpace(self):', '    def test_CreateAndSymbol(self):', '    def test_CreateComma(self):', '    def test_CreateBang(self):']
test_appDelete_keyNotFound.py
['def test_DeleteAppUnknown_noKey', 'def test_DeleteAppUnknown_appNameOnly', 'def test_DeleteAppUnknown_wrongVersion', 'def test_DeleteAppUnknown_wrongDeveloperName', '    def test_DeleteAppUnknown_noKey(self):', '    def test_DeleteAppUnknown_appNameOnly(self):', '    def test_DeleteAppUnknown_wrongVersion(self):', '    def test_DeleteAppUnknown_wrongDeveloperName(self):']
test_appAdd_IpAccessDedicated65535.py
['def test_CreateAppDockerIpAccessDedicatedTCP65535', 'def test_CreateAppDockerIpAccessDedicatedTCP065535', 'def test_CreateAppDockerIpAccessDedicatedHTTP65535', 'def test_CreateAppDockerIpAccessDedicatedHTTP065535', 'def test_CreateAppDockerIpAccessDedicatedUDP65535', 'def test_CreateAppDockerIpAccessDedicatedUDP065535', 'def test_CreateAppQCOWIpAccessDedicatedTCP65535', 'def test_CreateAppQCOWIpAccessDedicatedTCP065535', 'def test_CreateAppQCOWIpAccessDedicatedHTTP65535', 'def test_CreateAppQCOWIpAccessDedicatedHTTP065535', 'def test_CreateAppQCOWIpAccessDedicatedUDP65535', 'def test_CreateAppQCOWIpAccessDedicatedUDP065535', '    def test_CreateAppDockerIpAccessDedicatedTCP65535(self):', '    def test_CreateAppDockerIpAccessDedicatedTCP065535(self):', '    def test_CreateAppDockerIpAccessDedicatedHTTP65535(self):', '    def test_CreateAppDockerIpAccessDedicatedHTTP065535(self):', '    def test_CreateAppDockerIpAccessDedicatedUDP65535(self):', '    def test_CreateAppDockerIpAccessDedicatedUDP065535(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCP65535(self):', '    def test_CreateAppQCOWIpAccessDedicatedTCP065535(self):', '    def test_CreateAppQCOWIpAccessDedicatedHTTP65535(self):', '    def test_CreateAppQCOWIpAccessDedicatedHTTP065535(self):', '    def test_CreateAppQCOWIpAccessDedicatedUDP65535(self):', '    def test_CreateAppQCOWIpAccessDedicatedUDP065535(self):']
test_appAdd_portInvalidDigits.py
[' def test_CreateAppPortInvalidUnknown', 'def test_CreateAppPortInvalidDedicated', ' def test_CreateAppPortInvalidDedicatedShared', ' def test_CreateAppPortInvalidShared', '#    def test_CreateAppPortInvalidUnknown(self):', '    def test_CreateAppPortInvalidDedicated(self):', '#    def test_CreateAppPortInvalidDedicatedShared(self):', '#    def test_CreateAppPortInvalidShared(self):']
test_appAdd_unsupportedPortProtocol.py
['def test_CreateAppUnsupportedDedicated', ' def test_CreateAppUnsupportedProtocolIpAccessDedicatedOrShared', ' def test_CreateAppUnsupportedProtocolIpAccessShared', '    def test_CreateAppUnsupportedDedicated(self):', '#    def test_CreateAppUnsupportedProtocolIpAccessDedicatedOrShared(self):', '#    def test_CreateAppUnsupportedProtocolIpAccessShared(self):']
test_appAdd_defaultFlavorEmpty.py
['def test_CreateAppDefaultFlavorEmpty_Docker', 'def test_CreateAppDefaultFlavorEmpty_QCOW', 'def test_CreateAppDefaultFlavorNotExist_Docker', 'def test_CreateAppDefaultFlavorNotExist_QCOW', '    def test_CreateAppDefaultFlavorEmpty_Docker(self):', '    def test_CreateAppDefaultFlavorEmpty_QCOW(self):', '    def test_CreateAppDefaultFlavorNotExist_Docker(self):', '    def test_CreateAppDefaultFlavorNotExist_QCOW(self):']
createApp_imagepath.robot
['CreateApp - error shall be received with image_type=ImageTypeDocker deployment=kubernetes image_path=mypath', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=kubernetes image_path of bad domain', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=kubernetes image_path and access denied to registry', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=kubernetes image_path and invalid tag', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=kubernetes image_path tag doesnt exist', 'CreateApp - error shall be received with image_type=ImageTypeDocker deployment=docker image_path=mypath', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=docker image_path of bad domain', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=docker image_path and access denied to registry', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=docker image_path and invalid tag', 'CreateApp - error shall be received wih image_type=ImageTypeDocker deployment=docker image_path tag doesnt exist', 'CreateApp - error shall be received with image_type=ImageTypeQCOW deployment=vm image_path=mypath', 'CreateApp - error shall be received wih image_type=ImageTypeQCOW deployment=vm image_path of bad domain', 'CreateApp - error shall be received wih image_type=ImageTypeQCOW deployment=vm image_path and access denied to registry', 'CreateApp - error shall be received wih image_type=ImageTypeQCOW deployment=vm image_path and invalid tag', 'CreateApp - error shall be received wih image_type=ImageTypeQCOW deployment=vm image_path tag doesnt exist']
test_appAdd_IpAccessSharedMulti.py
['def test_CreateAppDockerIpAccessSharedTCP2Ports', 'def test_CreateAppDockerIpAccessSharedTCP10Ports', 'def test_CreateAppDockerIpAccessSharedTCP100Ports', 'def test_CreateAppDockerIpAccessSharedTCPUDPPorts', 'def test_CreateAppDockerIpAccessSharedHTTP2Ports', 'def test_CreateAppDockerIpAccessSharedHTTP10Ports', 'def test_CreateAppDockerIpAccessSharedHTTP100Ports', 'def test_CreateAppDockerIpAccessSharedTCPUDPHTTPPorts', 'def test_CreateAppDockerIpAccessSharedUDP2Ports', 'def test_CreateAppDockerIpAccessSharedUDP10Ports', 'def test_CreateAppDockerIpAccessSharedUDP100Ports', 'def test_CreateAppQCOWIpAccessSharedTCP2Ports', 'def test_CreateAppQCOWIpAccessSharedTCP10Ports', 'def test_CreateAppQCOWIpAccessSharedTCP100Ports', 'def test_CreateAppQCOWIpAccessSharedTCPUDPPorts', 'def test_CreateAppQCOWIpAccessSharedUDP2Ports', 'def test_CreateAppQCOWIpAccessSharedUDP10Ports', 'def test_CreateAppQCOWIpAccessSharedUDP100Ports', 'def test_CreateAppQCOWIpAccessSharedHTTP2Ports', 'def test_CreateAppQCOWIpAccessSharedHTTP10Ports', 'def test_CreateAppQCOWIpAccessSharedHTTP100Ports', 'def test_CreateAppQCOWIpAccessSharedTCPUDPHTTPPorts', '    def test_CreateAppDockerIpAccessSharedTCP2Ports(self):', '    def test_CreateAppDockerIpAccessSharedTCP10Ports(self):', '    def test_CreateAppDockerIpAccessSharedTCP100Ports(self):', '    def test_CreateAppDockerIpAccessSharedTCPUDPPorts(self):', '    def test_CreateAppDockerIpAccessSharedHTTP2Ports(self):', '    def test_CreateAppDockerIpAccessSharedHTTP10Ports(self):', '    def test_CreateAppDockerIpAccessSharedHTTP100Ports(self):', '    def test_CreateAppDockerIpAccessSharedTCPUDPHTTPPorts(self):', '    def test_CreateAppDockerIpAccessSharedUDP2Ports(self):', '    def test_CreateAppDockerIpAccessSharedUDP10Ports(self):', '    def test_CreateAppDockerIpAccessSharedUDP100Ports(self):', '    def test_CreateAppQCOWIpAccessSharedTCP2Ports(self):', '    def test_CreateAppQCOWIpAccessSharedTCP10Ports(self):', '    def test_CreateAppQCOWIpAccessSharedTCP100Ports(self):', '    def test_CreateAppQCOWIpAccessSharedTCPUDPPorts(self):', '    def test_CreateAppQCOWIpAccessSharedUDP2Ports(self):', '    def test_CreateAppQCOWIpAccessSharedUDP10Ports(self):', '    def test_CreateAppQCOWIpAccessSharedUDP100Ports(self):', '    def test_CreateAppQCOWIpAccessSharedHTTP2Ports(self):', '    def test_CreateAppQCOWIpAccessSharedHTTP10Ports(self):', '    def test_CreateAppQCOWIpAccessSharedHTTP100Ports(self):', '    def test_CreateAppQCOWIpAccessSharedTCPUDPHTTPPorts(self):']
test_appAdd_noParms.py
['def test_CreateAppNoParms', '    def test_CreateAppNoParms(self):']
test_appAdd_noPorts.py
['def test_CreateAppNoPortsDedicated', ' def test_CreateAppNoPortsIpAccessDedicatedorShared', ' def test_CreateAppNoPortsIpAccessShared', '    def test_CreateAppNoPortsDedicated(self):', '#    def test_CreateAppNoPortsIpAccessDedicatedorShared(self):', '#    def test_CreateAppNoPortsIpAccessShared(self):']
test_appAdd_developerEmpty.py
['def test_CreateAppDeveloperEmpty_Docker', 'def test_CreateAppDeveloperEmpty_QCOW', 'def test_CreateAppDeveloperNotExist_Docker', 'def test_CreateAppDeveloperNotExist_QCOW', '    def test_CreateAppDeveloperEmpty_Docker(self):', '    def test_CreateAppDeveloperEmpty_QCOW(self):', '    def test_CreateAppDeveloperNotExist_Docker(self):', '    def test_CreateAppDeveloperNotExist_QCOW(self):']
test_appAdd_docker.py
['def test_CreateAppDockerNoImagePath', 'def test_CreateAppDockerEmptyImagePath', '    def test_CreateAppDockerNoImagePath(self):', '    def test_CreateAppDockerEmptyImagePath(self):']
test_operatorAdd_invalidName.py
['def test_createOperatorStartUnderscore', 'def test_createOperatorParenthesis', 'def test_createOperatorDollarsign', 'def test_createOperatorOtherInvalidChars']
test_operatorAdd_100.py
['def test_createOperator']
test_operatorAdd.py
['def test_createOperator', 'def test_createOperatorSpace', 'def test_createOperatorUnderscore']
test_operatorAdd_noName.py
['def test_createOperatorEmptyName', 'def test_createOperatorNoName']
test_operatorDelete_beforeCloudlet.py
['def test_DeleteOperatorBeforeCloudlet']
test_operatorAdd_nameDeveloper.py
['def test_createOperator']
test_operatorAdd_multiControllers.py
['def test_createOperator']
test_operatorUpdate.py
['def test_updateOperator', 'def test_updateOperatorSpace']
test_operatorDelete.py
['def test_deleteOperator']
test_operatorAdd_sameName.py
['def test_createOperator']
test_operatorShow_single.py
['def test_ShowOperatorSingle']
test_operatorUpdate_unknown.py
['def test_updateOperatorUnknown']
test_operatorDelete_unknown.py
['def test_DeleteOperatorUnknown']
clusterFlavor.robot~
['CreateClusterFlavor without a key name']
clusterFlavor.robot
['CreateClusterFlavor without a key name']
test_showController_all.py
['def test_showControllersAll', '    def test_showControllersAll(self):']
test_showController_addr.py
['def test_showControllersAddr', '    def test_showControllersAddr(self):']
test_showController_wrongAddr.py
['def test_showControllersWrongAddr', '    def test_showControllersWrongAddr(self):']
test_flavorAdd_ram0.py
['def test_createFlavorRamOnly', 'def test_createFlavorRam0OtherParms', '    def test_createFlavorRamOnly(self):', '    def test_createFlavorRam0OtherParms(self):']
test_flavorAdd_vcpus0.py
['def test_createFlavorVcpusOnly', 'def test_createFlavorVcpus0OtherParms', '    def test_createFlavorVcpusOnly(self):', '    def test_createFlavorVcpus0OtherParms(self):']
test_flavorAdd_nameOnly.py
['def test_createFlavorNameOnly', '    def test_createFlavorNameOnly(self):']
test_flavorShow_single.py
['def test_showFlavor_nameOnly', '    def test_showFlavor_nameOnly(self):']
test_flavorAdd_invalidName.py
['def test_createFlavorStartUnderscore', 'def test_createFlavorParenthesis', 'def test_createFlavorDollarsign', 'def test_createFlavorOtherInvalidChars', '    def test_createFlavorStartUnderscore(self):', '    def test_createFlavorParenthesis(self):', '    def test_createFlavorDollarsign(self):', '    def test_createFlavorOtherInvalidChars(self):']
test_flavorAdd_largerThanMaxValues.py
['def test_createFlavorRamTooLarge', 'def test_createFlavorVcpusTooLarge', 'def test_createFlavorDiskTooLarge', '    def test_createFlavorRamTooLarge(self):', '    def test_createFlavorVcpusTooLarge(self):', '    def test_createFlavorDiskTooLarge(self):']
test_flavorAdd_sameName.py
['def test_createFlavorSameName', '    def test_createFlavorSameName(self):']
test_flavorDelete_unknown.py
['def test_DeleteDeveloperUnknown', '    def test_DeleteDeveloperUnknown(self):']
test_flavorDelete_beforeClusterFlavor.py
['def test_DeleteFlavorBeforeClusterFlavor', '    def test_DeleteFlavorBeforeClusterFlavor(self):']
test_flavorShow_ramVcupsDisk.py
['def test_showFlavor_ram', 'def test_showFlavor_disk', 'def test_showFlavor_vcpus', '    def test_showFlavor_ram(self):', '    def test_showFlavor_disk(self):', '    def test_showFlavor_vcpus(self):']
test_flavorUpdate_notSupported.py
['def test_updateFlavor', '    def test_updateFlavor(self):']
test_flavorAdd_disk0.py
['def test_createFlavorDisk0OtherParms', '    def test_createFlavorDisk0OtherParms(self):']
test_flavorAdd_noName.py
['def test_createFlavorEmptyName', 'def test_createFlavorNoName', 'def test_createFlavorNoNameOtherParms', '    def test_createFlavorEmptyName(self):', '    def test_createFlavorNoName(self):', '    def test_createFlavorNoNameOtherParms(self):']
test_flavorAdd_minValues.py
['def test_createFlavorMinValue', '    def test_createFlavorMinValue(self):']
test_flavorDelete_wrongParms.py
['def test_createFlavorMinValue', '    def test_createFlavorMinValue(self):']
test_flavorDelete_nameOnly.py
['def test_deleteFlavorNameOnly', '    def test_deleteFlavorNameOnly(self):']
test_flavorAdd_multiControllers.py
['def test_createFlavor']
test_flavorAdd_maxValues.py
['def test_createFlavorMaxValue', '    def test_createFlavorMaxValue(self):']
test_flavorAdd_invalidParms.py
['def test_createFlavorRamInvalid', 'def test_createFlavorVcpusInvalid', 'def test_createFlavorDiskInvalid', '    def test_createFlavorRamInvalid(self):', '    def test_createFlavorVcpusInvalid(self):', '    def test_createFlavorDiskInvalid(self):']
test_flavorAdd_100.py
['def test_createFlavor', '    def test_createFlavor(self):']
createCloudlet.robot
['CreateCloudlet with all parameters', 'CreateCloudlet without the optional parameters', 'CreateCloudlet with required parameters and accessuri', 'CreateCloudlet with required parameters and ipsupport', 'CreateCloudlet with required parameters and staticips']
updateCloutlet.robot
['UpdateCloudlet accessuri', 'UpdateCloudlet staticips', 'UpdateCloudlet number_of_dynamic_ips', 'UpdateCloudlet location ', 'UpdateCloudlet location lat', 'UpdateCloudlet location long', 'UpdateCloudlet optional accessuri', 'UpdateCloudlet optional staticips\t']
updateCloutlet_fail.robot
['UpdateCloudlet without an operator', 'UpdateCloudlet with an invalid operator', 'UpdateCloudlet without a cloudlet name', 'UpdateCloudlet with an invalid cloudlet name', 'UpdateCloudlet with a numdynamicips 0', 'UpdateCloudlet with a numdynamicips -1', 'UpdateCloudlet with a numdynamicips A', 'UpdateCloudlet with a numdynamicips 2323232232323', 'UpdateCloudlet with a ipsupport of -1', 'UpdateCloudlet with a ipsupport of -8', 'UpdateCloudlet with a location of 0 0 ', 'UpdateCloudlet with a location of 100 200 ', 'UpdateCloudlet with a location of 90 200 ', 'UpdateCloudlet with a location of -100 -200 ', 'UpdateCloudlet with a location of -90 -200 ', 'UpdateCloudlet with a location of A A ', 'UpdateCloudlet with accessuri of 6 ', 'UpdateCloudlet with staticips of 6 ']
updateCloutlet_fail.robot~
['UpdateCloudlet - without an operator', 'UpdateCloudlet - with an invalid operator', 'UpdateCloudlet - without a cloudlet name', 'UpdateCloudlet - with an invalid cloudlet name', 'UpdateCloudlet - with a numdynamicips 0', 'UpdateCloudlet - with a numdynamicips -1', 'UpdateCloudlet - with a numdynamicips A', 'UpdateCloudlet - with a numdynamicips 2323232232323', 'UpdateCloudlet - with a ipsupport of -1', 'UpdateCloudlet - with a ipsupport of -8', 'UpdateCloudlet - with a location of 0 0 ', 'UpdateCloudlet - with a location of A A ', 'UpdateCloudlet - with accessuri of 6 ', 'UpdateCloudlet - with staticips of 6 ']
deleteCloudlet.robot
['DeleteCloudlet without an operator', 'DeleteCloudlet with an invalid operator', 'DeleteCloudlet without a cloudlet name', 'DeleteCloudlet with an invalid cloudlet name', 'DeleteCloudlet with a static app assigned', 'DeleteCloudlet with a static cluster instance assigned', 'DeleteCloudlet with a valid operator and cloudlet name']
createCloudlet_fail.robot
['CreateCloudlet without an operator', 'CreateCloudlet with an invalid operator', 'CreateCloudlet without a name', 'CreateCloudlet without a location', 'CreateCloudlet with a location of 0 0', 'CreateCloudlet with a location of 100 200', 'CreateCloudlet with a location of 90 200', 'CreateCloudlet with a location of -100 -200', 'CreateCloudlet with a location of -90 -200', 'CreateCloudlet with numdynamic set to 0', 'CreateCloudlet with an invalid ipsupport enumeration -1', 'CreateCloudlet with an invalid ipsupport IPSupportStatic', 'CreateCloudlet with an invalid ipsupport enumeration 3']
showCloudlet.robot
['ShowCloudlets all', 'ShowCloudlets selected', 'ShowCloudlets invalid']
rootlb_sshAccess.robot
['Openstack rootlb ssh access should be protected']
mc_traffic_rest.robot
['MC - Login mc requests admin user Traffic ', 'MC - Create User requests create different users Traffic ', 'MC - Login mc requests different users Traffic ', 'MC - Current users mc requests different users Traffic ', 'MC - Show Role mc requests admin user Traffic ', 'MC - Show Role mc requests different users Traffic ', 'MC - Create Org mc requests different users Traffic ', 'MC - Show Org mc requests different users Traffic ', 'MC - Adduser Role mc requests different users Traffic ']
mc_org_delete.robot
['MC - Delete an org without an org name\t', "MC - Delete an org that doesn't exist admin token\t", "MC - Delete an org that doesn't exist user token\t", 'MC - Delete an org without a token\t', 'MC - Delete an org with an empty token\t', 'MC - Delete an org with a bad token\t', 'MC - Delete an org with an expired token\t', 'MC - Delete an org with a user assigned admin token\t', 'MC - Delete an org with a user assigned user token\t', 'MC - Delete an org created by user1 using user2 token']
mc_login_newuser.robot
['MC - New User shall be able to successfully login', 'MC - New User shall be able to login with thier email and password', 'MC - New User with wrong password shall not be able to login', 'MC - New User with wrong username shall not be able to login', 'MC - New User with no username shall not be able to login', 'MC - New User with no password shall not be able to login', 'MC - New User with empty username shall not be able to login', 'MC - New User with empty password shall not be able to login']
mc_login_newpass.robot
['MC - Admin user shall be able to change the password', 'MC - Admin user shall be able to login with the new password ', 'MC - Admin user shall not be able to login with the old password ', 'MC - User shall be able to change their password', 'MC - User shall be able to change to the same password as another user', 'MC - User shall not be able to login with the old password ', 'MC - User shall not be able to change their password without a token', 'MC - User shall not be able to change their password with an empty token', 'MC - User shall not be able to change their password with a bad token', 'MC - User shall not be able to change their password with an expired token']
mc_createUser.robot
['MC - User shall be able to create a new user', 'MC - User shall not be able to create a new user with no username', 'MC - User shall not be able to create a new user with empty username', 'MC - User shall not be able to create a new user with no password', 'MC - User shall not be able to create a new user with empty password', 'MC - User shall not be able to create a new user without an email', 'MC - User shall not be able to create a new user with an empty email', 'MC - User shall not be able to create a new user with :: in the username', 'MC - User shall not be able to create a new user with an invalid email', 'MC - User shall not be able to create a new user with an invalid username characters  ', 'MC - User shall not be able to create a new user with spaces before the username   ', 'MC - User shall not be able to create a new user with an invalid password', 'MC - User shall not be able to create the same new user twice same info', 'MC - User shall not be able to create the same new user twice different password', 'MC - User shall not be able to create the same new user twice different email', 'MC - User shall not be able to create the superuser twice same info', 'MC - User shall not be able to create the superuser twice different password', 'MC - User shall not be able to create the superuser twice different email']
mc_role_assignment_show.robot
['MC - Admin user shall be able to show role assignments', 'MC - User shall be able to show role assignments', 'MC - User shall not be able to show role assignments without a token', 'MC - User shall not be able to show role assignments with an empty token', 'MC - User shall not be able to show role assignments with a bad token', 'MC - User shall not be able to show role assignments with an expired token']
mc_deleteuser.robot
['MC - Delete a user without a user name\t', 'MC - Delete a user without a token\t', 'MC - Delete a user with an empty token\t', 'MC - Delete a user with a bad token\t', 'MC - Delete a user with an expired token\t']
mc_role_show.robot
['MC - Admin user shall be able to show roles', 'MC - User shall be able to show roles', 'MC - User shall not be able to show roles without a token', 'MC - User shall not be able to show roles with an empty token', 'MC - User shall not be able to show roles with a bad token', 'MC - User shall not be able to show roles with an expired token']
mc_role_removeuser.robot
['MC - Admin remove an AdminManager role from a user ', 'MC - Admin remove an AdminCondtributor role from a user ', 'MC - Admin remove an AdminViewer role from a user ', 'MC - Admin remove an DeveloperManager role from a user ', 'MC - Remove a user role from a user with a bad token']
mc_org_create.robot
['MC - Show org with admin user no orgs created', 'MC - Add an Admin org with the admin user', 'MC - Add a developer org with the admin user', 'MC - Add a operator org with the admin user', 'MC - Admin user can create multiple organizations', 'MC - New user can create a developer org', 'MC - New user can create a operator org', 'MC - New user can create multiple organizations', 'MC - Admin user can see orgs created by other users', 'MC - Create an org without an org name\t', 'MC - Create an org without an org type\t', 'MC - Create an org without an org address\t', 'MC - Create an org without an org phone\t', 'MC - Create an org without a token\t', 'MC - Create an org with an empty token\t', 'MC - Create an org with a bad token\t', 'MC - Create an org with an expired token\t']
mc_role_adduser.robot
['MC - Admin user shall be able show role assignments with no assignments', 'MC - Admin user shall be able to assign a user role to an org', 'MC - Admin user shall be able to assign a manager user role to an org', 'MC - Admin user shall be able to assign Developer user roles to a developer org', 'MC - Admin user shall be able to assign Operator user roles to a operator org', 'MC - Admin user shall be able to assign all user roles to users', 'MC - A user shall be able to assign a user role to an org they created', 'MC - DeveloperManager shall be able to assign all Developer roles to users', 'MC - OperatorManager shall be able to assign all Operator roles to users\t', 'MC - Assign a user role to a user without a token', 'MC - Assign a user role to a user with an empty token', 'MC - Assign a user role to a user with a bad token', 'MC - Assign a user role to a user with an expired token']
mc_login_superuser.robot
['MC - Superuser shall be able to successfully login', 'MC - Superuser with wrong password shall not be able to login', 'MC - Superuser with wrong username shall not be able to login', 'MC - Superuser with no username shall not be able to login', 'MC - Superuser with no password shall not be able to login', 'MC - Superuser with empty username shall not be able to login', 'MC - Superuser with empty password shall not be able to login', 'MC - User with empty username/password shall not be able to login', 'MC - User with no username/password shall not be able to login', 'MC - User with invalid json shall not be able to login', 'MC - User with wrong parm name shall not be able to login']
mc_currentUser.robot
['MC - User shall be able to get the current status of superuser', 'MC - User shall be able to get the current status of new user', 'MC - User with no token shall not be able to get current status', 'MC - User with an empty token shall not be able to get current status', 'MC - User with bad token1 shall not be able to get current status', 'MC - User with bad token2 shall not be able to get current status', 'MC - User with expired token shall not be able to get current status of superuser', 'MC - User with expired token shall not be able to get current status of newuser']
app_show.robot
['Web UI - user shall be able show US apps', 'Web UI - user shall be able show EU flavors', 'Web UI - user shall be able show All flavors']
cloudlet_create.robot
['Web UI - user shall be able to create a new EU cloudlet', '#Web UI - user shall be able to create a new US flavor']
cloudlet_show.robot
['Web UI - user shall be able show US cloudlets', 'Web UI - user shall be able show EU cloudlets', 'Web UI - user shall be able show All cloudlets']
cloudlet_sort.robot
['Web UI - user shall be able to sort cloudlets by cloudlet name', 'Web UI - user shall be able to sort cloudlets by region']
appInst_show.robot
['Web UI - user shall be able show US app instances', 'Web UI - user shall be able show EU flavors', 'Web UI - user shall be able show All flavors']
flavor_show.robot
['Web UI - user shall be able show US flavors', 'Web UI - user shall be able show EU flavors', 'Web UI - user shall be able show All flavors']
loginpy.robot
['Login to console']
flavor_create.robot
['Web UI - user shall be able to create a new EU flavor', 'Web UI - user shall be able to create a new US flavor']
cloudlet_details.robot
['Web UI - user shall be able cloudlet details']
